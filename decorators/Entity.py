from inspect import getmembers
from db.DBManager import instance as db
from db.DButil import DBUtil
from db.relationships import Relationship, OneToMany
from decorators.AutoGenerated import AutoGenerated
from utils.IsDBNative import is_db_native

class Entity():
    def __init__(self, __table__):
        self.__table__ = __table__


    def __call__(self, clazz: type):
        members = getmembers(clazz)[0][1] # [0][1] -> __annotations__
        relations = []
        fields = []

        for member in members:
            if isinstance(members[member], Relationship):
                relations.append(member)
            else:
                fields.append(member)


        def __save__(self, do_after=None):
            if not self.__changed__:
                return

            if self.__managed__:
                self.__update__()
                return

            values = dict()

            for field in fields:
                if isinstance(members[field], AutoGenerated) and not hasattr(self, field):
                    continue
                attr = getattr(self, field)

                if not is_db_native(attr):
                    print(f"{field} was not db native, do not know how to handle")
                    continue

                values[field] = attr

            db.execute(DBUtil.insert(self.__table__, values), do_after=do_after)
            self.__managed__ = True

        def __update__(self):
            values = dict()

            for field in fields:
                attr = getattr(self, field)

                if not is_db_native(attr):
                    print(f"{field} was not db native, do not know how to handle")
                    continue

                values[field] = attr
            # TODO: Generalize this to rely on a PK rather than presuming an ID
            db.execute(DBUtil.update_by_id(self.__table__, values, self.id))

        def save(self):
            def inner(cursor):
                inserted_id = cursor.lastrowid
                if not inserted_id:
                    return
                self.id = inserted_id
                for relation in relations:
                    relation_value = members[relation]
                    if isinstance(relation_value, OneToMany):
                        for v in relation_value._value:
                            self_attr = getattr(self, relation_value.inverse_mapped_by)
                            setattr(v, relation_value.mapped_by, self_attr)

                        relation_value.save()

                        
            self.__save__(do_after=inner)
        
        def delete(self):
            # TODO: Generalize this to rely on a PK rather than presuming an ID
            db.execute(DBUtil.delete_by_id(self.__table__, self.id))

        def back_to_entity(obj, row: dict):
            for field in fields:
                setattr(obj, field, row[field])
            return obj                

        @classmethod
        def get_all(cls):
            ret = []
            raw = db.query(DBUtil.select_all(self.__table__))
            for row in raw:
                obj = cls()
                ret.append(back_to_entity(obj, row))
                obj.__managed__ = True
                obj.__changed__ = False # It has not changed, it has been retrieved from db

            return ret

        
        @classmethod
        def get_by_id(cls, id):
            raw = db.query(DBUtil.select_by_id(self.__table__, id))
            obj = cls()
            back_to_entity(obj, raw[0])
            obj.__managed__ = True
            obj.__changed__ = False

            return obj

        @classmethod
        def get_all_where(cls, where):
            ret = []
            raw = db.query(DBUtil.select_all_where(self.__table__, where))
            for row in raw:
                obj = cls()
                ret.append(back_to_entity(obj, row))
                obj.__managed__ = True
                obj.__changed__ = False
            
            return ret

                
        def init_factory(table_name):
            def init(self):
                self.__changed__ = False
                self.__managed__ = False
                self.__table__ = table_name
                for relation in relations:
                    members[relation].foobar = self
            return init

        def get_factory(field):
            def _get(self):
                return getattr(self, field)
            return _get
        
        def set_factory(field):
            def _set(self, value):
                self.__changed__ = True
                setattr(self, field, value)
            return _set


        fields_to_set = {
            "__init__": init_factory(self.__table__),
            "__update__": __update__,
            "__save__": __save__,
            'save': save,
            'get_all': get_all,
            'get_by_id': get_by_id,
            'get_all_where': get_all_where,
            'delete': delete
        }

        for field in fields:
            backer = f"__{field}__"
            fields_to_set[field] = property(get_factory(backer), set_factory(backer))

        for relation in relations:
            fields_to_set[relation] = members[relation]

        to_return = type(clazz.__name__, (Entity,), fields_to_set)


        return to_return

